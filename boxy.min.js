var boxy=function(t){"use strict";
    function e(t){var e=Object.create(null);
    return t&&Object.keys(t).forEach((function(s){if("default"!==s){var i=Object.getOwnPropertyDescriptor(t,s);
    Object.defineProperty(e,s,i.get?i:{enumerable:!0,get:function(){return t[s]}})}})),e.default=t,Object.freeze(e)}var s=e(t);
class i extends s.Scene{constructor(){super({key:"TitleScene"}),this.options=["Easy Mode","Normal Mode","Options"],this.defaultTextStyle={fontSize:"32px",fill:"#bbb"},this.highlightedTextStyle={fontSize:"32px",fill:"#fff"}}create(){this.selectedOptionIndex=0,this.optionButtons=[],this.countdownDuration=5e3,this.playerIcon=null,this.countdownTimer=null,this.cameras.main.setBackgroundColor("#008000"),this.add.text(400,100,"Game Title",{fontSize:"64px",fill:"#bbb"}).setOrigin(.5);
this.options.forEach(((t,e)=>{let s=this.add.text(450,200+100*e,t,{fontSize:"32px",fill:0==e?"#fff":"#bbb"}).setOrigin(0,.5).setInteractive();
s.on("pointerdown",(()=>{this.selectedOptionIndex=e,this.startSelectedOption()})),s.on("pointerover",(()=>{this.selectedOptionIndex=e,this.updatePlayerIconPosition(),this.clearCountdownTimer(),s.setStyle(this.highlightedTextStyle)})),this.optionButtons.push(s)}));
let t=this.game.registry.get("playerColor");
t=void 0===t?16711680:t,this.playerIcon=this.add.rectangle(400,200+100*this.selectedOptionIndex,32,48,t).setOrigin(.5),this.countdownText=this.add.text(400,550,"",this.defaultTextStyle).setOrigin(.5),this.cursors=this.input.keyboard.createCursorKeys(),this.enterKey=this.input.keyboard.addKey(s.Input.Keyboard.KeyCodes.ENTER),this.resetCountdownTimer()}update(t,e){s.Input.Keyboard.JustDown(this.cursors.up)?(this.selectedOptionIndex=(this.selectedOptionIndex+this.options.length-1)%this.options.length,this.updatePlayerIconPosition(),this.clearCountdownTimer()):s.Input.Keyboard.JustDown(this.cursors.down)?(this.selectedOptionIndex=(this.selectedOptionIndex+1)%this.options.length,this.updatePlayerIconPosition(),this.clearCountdownTimer()):s.Input.Keyboard.JustDown(this.enterKey)&&this.startSelectedOption(),this.countdownTimer&&(this.countdownRemaining=this.countdownDuration-this.countdownTimer.getElapsed()),this.countdownText&&this.countdownText.setText("Starting in "+Math.ceil(this.countdownRemaining/1e3)+" seconds...")}updatePlayerIconPosition(){let t=this.game.registry.get("playerColor");
    t=void 0===t?16711680:t,this.playerIcon.setFillStyle(t),this.playerIcon.y=200+100*this.selectedOptionIndex,this.optionButtons.forEach(((t,e)=>{e===this.selectedOptionIndex?t.setStyle(this.highlightedTextStyle):t.setStyle(this.defaultTextStyle)}))}startSelectedOption(){switch(this.selectedOptionIndex){case 0:this.scene.start("MainScene",{level:1,gameMode:"easy"});
break;
case 1:this.scene.start("MainScene",{level:1,gameMode:"normal"});
break;
case 2:this.scene.start("OptionsScene")}}resetCountdownTimer(){this.countdownTimer&&this.countdownTimer.remove(),this.countdownTimer=this.time.delayedCall(this.countdownDuration,(()=>{this.selectedOptionIndex=0,this.startSelectedOption()}),[],this)}clearCountdownTimer(){this.countdownTimer&&(this.countdownTimer.remove(),this.countdownTimer=null),this.countdownText&&(this.countdownText.setText(""),this.countdownText=null)}}class h extends s.Scene{constructor(){super({key:"OptionsScene"})}create(){this.selectedColorIndex=0,this.colorButtons=[],this.defaultButtonStyle={lineWidth:2,strokeStyle:16777215},this.selectedButtonStyle={lineWidth:4,strokeStyle:16776960},this.cameras.main.setBackgroundColor("#000000"),this.add.text(400,50,"Options",{fontSize:"48px",fill:"#fff"}).setOrigin(.5),this.add.text(400,100,"Select Player Color",{fontSize:"24px",fill:"#fff"}).setOrigin(.5),this.colors=[{color:16711680,label:"Red",x:150,y:200},{color:65280,label:"Green",x:300,y:200},{color:255,label:"Blue",x:450,y:200},{color:16776960,label:"Yellow",x:600,y:200},{color:16711935,label:"Magenta",x:150,y:350},{color:65535,label:"Cyan",x:300,y:350},{color:16777215,label:"White",x:450,y:350},{color:0,label:"Black",x:600,y:350}],this.colors.forEach(((t,e)=>{let s=this.add.rectangle(t.x,t.y,100,100,t.color).setInteractive();
    s.on("pointerdown",(()=>{this.game.registry.set("playerColor",t.color),this.scene.start("TitleScene")})),s.on("pointerover",(()=>{this.selectedColorIndex=e,this.updateColorSelection()})),s.setStrokeStyle(this.defaultButtonStyle.lineWidth,this.defaultButtonStyle.strokeStyle),this.colorButtons.push(s)})),this.cancelButton=this.add.text(400,500,"Cancel",{fontSize:"32px",fill:"#888"}).setOrigin(.5).setInteractive(),this.cancelButton.on("pointerdown",(()=>{this.scene.start("TitleScene")})),this.cancelButton.on("pointerover",(()=>{this.cancelButton.setStyle({fill:"#fff"}),this.selectedColorIndex=-1,this.updateColorSelection()})),this.cancelButton.on("pointerout",(()=>{this.cancelButton.setStyle({fill:"#888"})})),this.cursors=this.input.keyboard.createCursorKeys(),this.enterKey=this.input.keyboard.addKey(s.Input.Keyboard.KeyCodes.ENTER),this.escapeKey=this.input.keyboard.addKey(s.Input.Keyboard.KeyCodes.ESC),this.updateColorSelection(),this.input.on("pointerdown",((t,e)=>{e.length})),this.events.on("shutdown",this.shutdown,this)}update(){if(s.Input.Keyboard.JustDown(this.cursors.left))-1===this.selectedColorIndex?this.selectedColorIndex=this.colorButtons.length-1:this.selectedColorIndex%4>0?this.selectedColorIndex-=1:this.selectedColorIndex+=3,this.updateColorSelection();
    else if(s.Input.Keyboard.JustDown(this.cursors.right))-1===this.selectedColorIndex?this.selectedColorIndex=0:this.selectedColorIndex%4<3?this.selectedColorIndex+=1:this.selectedColorIndex-=3,this.updateColorSelection();
    else if(s.Input.Keyboard.JustDown(this.cursors.up))-1===this.selectedColorIndex?this.selectedColorIndex=4:this.selectedColorIndex-4>=0?this.selectedColorIndex-=4:this.selectedColorIndex=-1,this.updateColorSelection();
    else if(s.Input.Keyboard.JustDown(this.cursors.down))-1===this.selectedColorIndex||(this.selectedColorIndex+4<this.colorButtons.length?this.selectedColorIndex+=4:this.selectedColorIndex=-1),this.updateColorSelection();
    else if(s.Input.Keyboard.JustDown(this.enterKey))if(-1===this.selectedColorIndex)this.scene.start("TitleScene");
    else{const t=this.colors[this.selectedColorIndex];
    this.game.registry.set("playerColor",t.color),this.scene.start("TitleScene")}else s.Input.Keyboard.JustDown(this.escapeKey)&&this.scene.start("TitleScene")}updateColorSelection(){this.colorButtons.forEach(((t,e)=>{e===this.selectedColorIndex?t.setStrokeStyle(this.selectedButtonStyle.lineWidth,this.selectedButtonStyle.strokeStyle):t.setStrokeStyle(this.defaultButtonStyle.lineWidth,this.defaultButtonStyle.strokeStyle)}))}shutdown(){this.input.keyboard.shutdown(),this.input.off("pointerdown"),this.events.off("shutdown",this.shutdown,this)}}class a{constructor(t,e={}){this.scene=t,this.keys=e.keys||["LEFT","RIGHT","UP","DOWN","SPACE","SHIFT"],this.keySize=e.keySize||{width:100,height:50},this.margin=e.margin||10,this.position=e.position||{x:50,y:568},this.keyPositions=e.keyPositions||{LEFT:{x:0,y:0},RIGHT:{x:1,y:0},UP:{x:6.25,y:0},DOWN:{x:2,y:0},SPACE:{x:0,y:0,hidden:!0},SHIFT:{x:5.25,y:0}},this.buttons={},this.virtualKeys={left:!1,right:!1,up:!1,down:!1,space:!1,shift:!1},this.createKeyboard(),this.initializeVirtualKeyListeners()}initializeVirtualKeyListeners(){this.scene.input.addPointer(3),Object.keys(this.virtualKeys).forEach((t=>{const e=this.buttons[t.toUpperCase()].button;
    e&&e.on("pointerdown",(()=>this.virtualKeys[t]=!0)).on("pointerup",(()=>this.virtualKeys[t]=!1)).on("pointerout",(()=>this.virtualKeys[t]=!1))})),document.querySelector("canvas").addEventListener("mouseleave",(()=>{Object.keys(this.virtualKeys).forEach((t=>{this.virtualKeys[t]=!1}))}))}createKeyboard(){const{x:t,y:e}=this.position;
let s=t,i=e;
this.keys.forEach(((h,a)=>{if(this.keyPositions[h]){if(this.keyPositions[h].hidden)return void(this.buttons[h]={button:null,label:null});
s=t+this.keyPositions[h].x*(this.keySize.width+this.margin),i=e-this.keyPositions[h].y*(this.keySize.height+this.margin)}else s=t+a*(this.keySize.width+this.margin),s>this.scene.sys.game.config.width-this.keySize.width?(s=t,i=e-this.keySize.height+this.margin):i=e;
const r=this.scene.add.rectangle(s,i,this.keySize.width,this.keySize.height,6710886);
r.setInteractive();
const o=this.scene.add.text(s,i,h,{fontSize:"16px",fill:"#ffffff"}).setOrigin(.5);
this.buttons[h]={button:r,label:o}}))}destroy(){Object.values(this.buttons).forEach((({button:t,label:e})=>{t.destroy(),e.destroy()})),this.buttons={}}}class r{constructor(t,e){this.scene=t,this.cursors=this.scene.input.keyboard.createCursorKeys(),this.wasd=this.scene.input.keyboard.addKeys("W,S,A,D"),/Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent)||"ontouchstart"in window&&navigator.maxTouchPoints>0?this.virtualKeyboard=new a(t,{}):this.virtualKeyboard={virtualKeys:{}},this.shiftKey=this.scene.input.keyboard.addKey(s.Input.Keyboard.KeyCodes.SHIFT)}isLeftPressed(){return this.cursors.left.isDown||this.wasd.A.isDown||this.virtualKeyboard.virtualKeys.left}isRightPressed(){return this.cursors.right.isDown||this.wasd.D.isDown||this.virtualKeyboard.virtualKeys.right}isUpPressed(){return this.cursors.up.isDown||this.wasd.W.isDown||this.virtualKeyboard.virtualKeys.up}isDownPressed(){return this.cursors.down.isDown||this.wasd.S.isDown||this.virtualKeyboard.virtualKeys.down}isSpacePressed(){return this.cursors.space.isDown||this.virtualKeyboard.virtualKeys.space}isShiftPressed(){const t=s.Input.Keyboard.JustDown(this.shiftKey)||this.virtualKeyboard.virtualKeys.shift;
    return this.virtualKeyboard.virtualKeys.shift=!1,t}}class o{constructor(t={}){this.starIncreasePerLevel=t.starIncreasePerLevel||2,this.spikeDamage=t.spikeDamage||.5,this.numberOfBalls=t.numberOfBalls||22,this.game={getProgression:function(t){if("easy"===t)return[{levelType:"StarLevel",levelIndexInType:1},{levelType:"FloatingStarLevel",levelIndexInType:1},{levelType:"BallLevel",levelIndexInType:1}];
{let t=[],e=1;
    for(let s=0;
    s<10;
    s++)t.push({levelType:"StarLevel",levelIndexInType:e++});
e=1;
for(let s=0;
    s<5;
    s++)t.push({levelType:"FloatingStarLevel",levelIndexInType:e++});
return t.push({levelType:"BallLevel",levelIndexInType:1}),t}}}}getStarLevelOptions(t){return{starIncreasePerLevel:this.starIncreasePerLevel,spikeDamage:this.spikeDamage,levelIndexInType:t}}getFloatingStarLevelOptions(t){return{levelIndexInType:t}}getBallLevelOptions(t){return{numberOfBalls:this.numberOfBalls,elasticity:1}}}class l{constructor(t=1,e={}){this.level=t,this.weightSlowFactor=e.weightSlowFactor||.05,this.minPlayerSpeed=e.minPlayerSpeed||.5,this.maxPlayerSpeed=e.maxPlayerSpeed||1.2,this.weightJumpFactor=e.weightJumpFactor||.01,this.minPlayerJumpSpeed=e.minPlayerJumpSpeed||.8,this.maxPlayerJumpSpeed=e.maxPlayerJumpSpeed||2,this.maxJumpTime=e.maxJumpTime||300,this.jumpSpeed=e.jumpSpeed||-330,this.gravityY=e.gravityY||300,this.defaultItemBounce=e.defaultItemBounce||{x:.8,y:.8}}}class n{constructor(t,e={}){if(this.scene=t,this.size=e.size||{width:10,height:10},this.shape=e.shape||"triangle",this.speed=e.speed||500,this.color=e.color||16776960,this.cooldown=e.cooldown||200,this.recoilForce=e.recoilForce||100,this.textureKey="projectile_"+this.shape+"_"+this.color.toString(16),!this.scene.textures.exists(this.textureKey)){let t=this.scene.add.graphics({fillStyle:{color:this.color}});
"triangle"===this.shape?t.fillTriangle(0,this.size.height,this.size.width/2,0,this.size.width,this.size.height):"circle"===this.shape&&t.fillCircle(this.size.width/2,this.size.height/2,this.size.width/2),t.generateTexture(this.textureKey,this.size.width,this.size.height),t.destroy()}}}class c{constructor(){this.items={},this.totalWeight=0}addItem(t,e=1,s=0){this.items[t]?this.items[t].quantity+=e:this.items[t]={quantity:e,weight:s},this.totalWeight+=s*e}removeItem(t,e=1){this.items[t]&&(this.items[t].quantity-=e,this.totalWeight-=this.items[t].weight*e,this.items[t].quantity<=0&&delete this.items[t])}}class d{constructor(t,e={}){if(t instanceof Array==!1)throw new Error("AsciiMap must be an array of strings.");
    const s=t.findIndex((t=>t.match(/^-+$/)));
    s>-1?(this.asciiMap=t.slice(s+1),this.levelWidth=t[s+1].length):(this.asciiMap=t,this.levelWidth=t[0].length),this.tileSize=32,this.levelHeight=this.asciiMap.length,this.spikeTines=e.spikeTines||4}parse(){const t=[],e=[],s=[],i=[],h=[],a={w:(e,s)=>{t.push(this.createWall(e,s))},p:(t,s)=>{e.push(this.createPlatform(t,s))},s:(t,e)=>{s.push(this.createSpike(t,e))},e:(t,e)=>{i.push(this.createEnemy(t,e,"e"))},E:(t,e)=>{i.push(this.createEnemy(t,e,"E"))},h:(t,e)=>{h.push(this.createItem(t,e,"h"))},H:(t,e)=>{h.push(this.createItem(t,e,"H"))}};
for(let t=0;
    t<this.levelHeight;
    t++){const e=this.asciiMap[t];
    for(let s=0;
    s<this.levelWidth;
    s++){const i=a[e[s]];
    if(i){i(s*this.tileSize,t*this.tileSize)}}}return{wallData:t,platformData:e,spikeData:s,enemyData:i,itemData:h}}createWall(t,e){return{x:t+this.tileSize/2,y:e+this.tileSize/2,width:this.tileSize,height:this.tileSize,color:9127187}}createPlatform(t,e){return{x:t+this.tileSize/2,y:e+this.tileSize/2,width:this.tileSize,height:this.tileSize/2,color:8388736}}createSpike(t,e){return{x:t+this.tileSize/2,y:e+this.tileSize/2,width:this.tileSize,height:this.tileSize,tines:this.spikeTines,color:8421504}}createEnemy(t,e,s){return{x:t+this.tileSize/2,y:e+this.tileSize/2,type:s}}createItem(t,e,s){return{x:t+this.tileSize/2,y:e+this.tileSize/2,type:s}}}class p{constructor(t,e,s,i){this.scene=t,this.player=s,this.level=i,this.type=e.type,this.x=e.x,this.y=e.y,this.initialX=this.x,this.initialY=this.y,this.resetPatrol=!1,"e"===this.type?(this.color=16753920,this.shape="oval",this.damage=1,this.patrolDistance=200,this.gravity=!0,this.collidesWithLevel=!0,this.maxHealth=2,this.senseDistance=e.senseDistance||150,this.speed=e.speed||50,this.jumpHeight=e.jumpHeight||10,this.jumpSpeed=e.jumpSpeed||-300,this.jumpCooldown=1e3,this.lastJumpTime=0,this.direction=1):"E"===this.type&&(this.color=16711680,this.shape="diamond",this.damage=2,this.patrolDistance=210,this.gravity=!1,this.collidesWithLevel=!1,this.maxHealth=3,this.chaseDistance=e.chaseDistance||300,this.speed=e.speed||100,this.returnSpeed=e.returnSpeed||100,this.tolerance=5,this.state="bobbing",this.direction=1,this.bobAmplitude=20),this.health=this.maxHealth,this.createSprite(),t.physics.add.existing(this.sprite),this.gravity||(this.sprite.body.allowGravity=!1),this.collidesWithLevel&&(t.physics.add.collider(this.sprite,i.walls),t.physics.add.collider(this.sprite,i.platforms),t.physics.add.collider(this.sprite,i.spikes),t.physics.add.collider(this.sprite,i.enemies)),t.physics.add.overlap(this.sprite,s.sprite,this.hitPlayer,null,this),t.physics.add.overlap(this.sprite,s.projectiles,this.hitByProjectile,null,this),this.sprite.setData("instance",this)}hitByProjectile(t,e){this.health-=1,e.destroy(),this.health<=0?(t.destroy(),this.player.score+=20,this.player.scoreText.setText("Score: "+this.player.score)):this.scene.tweens.add({targets:t,duration:100,alpha:.5,yoyo:!0,repeat:0,onComplete:()=>{t.alpha=1}})}createSprite(){"oval"===this.shape?this.sprite=this.scene.add.ellipse(this.x,this.y,30,40,this.color):"diamond"===this.shape&&(this.sprite=this.scene.add.polygon(this.x,this.y,[0,-20,15,0,0,20,-15,0],this.color)),this.scene.physics.add.existing(this.sprite),this.sprite.body.setCollideWorldBounds(!0),this.sprite.body.onWorldBounds=!0}update(t,e){"E"===this.type?this.updateETypeEnemy(t):"e"===this.type&&this.updateeTypeEnemy(t)}updateETypeEnemy(t){const e=s.Math.Distance.Between(this.sprite.x,this.sprite.y,this.player.sprite.x,this.player.sprite.y);
    switch(this.state){case"bobbing":const t=this.initialY+Math.cos(this.scene.time.now/500)*this.bobAmplitude;
    this.sprite.y=s.Math.Clamp(t,this.initialY-this.bobAmplitude,this.initialY+this.bobAmplitude),this.sprite.x>=this.initialX+this.patrolDistance/2?(this.direction=-1,this.sprite.body.setVelocityY(0),this.sprite.y=this.initialY):this.sprite.x<=this.initialX-this.patrolDistance/2&&(this.direction=1,this.sprite.body.setVelocityY(0),this.sprite.y=this.initialY),this.sprite.body.setVelocityX(50*this.direction),e<=this.chaseDistance&&(this.state="chasing");
    break;
    case"chasing":this.scene.physics.moveToObject(this.sprite,this.player.sprite,this.speed),e>this.chaseDistance&&(this.state="returning");
    break;
    case"returning":s.Math.Distance.Between(this.sprite.x,this.sprite.y,this.initialX,this.initialY)>this.tolerance?this.scene.physics.moveTo(this.sprite,this.initialX,this.initialY,this.returnSpeed):(this.sprite.body.setVelocity(0,0),this.direction=1,this.sprite.x=this.initialX,this.sprite.y=this.initialY,this.state="bobbing")}}updateeTypeEnemy(t){if(s.Math.Distance.Between(this.sprite.x,this.sprite.y,this.player.sprite.x,this.player.sprite.y)<=this.senseDistance){if(this.resetPatrol=!0,this.sprite.x<this.player.sprite.x?(this.sprite.body.setVelocityX(this.speed),this.direction=1):this.sprite.x>this.player.sprite.x?(this.sprite.body.setVelocityX(-this.speed),this.direction=-1):this.sprite.body.setVelocityX(0),this.jumpHeight>0){const t=this.player.sprite.y-this.sprite.y;
    Math.abs(this.player.sprite.x-this.sprite.x)<100&&t<-50&&t>-200&&this.scene.time.now-this.lastJumpTime>this.jumpCooldown&&this.sprite.body.onFloor()&&(this.sprite.body.setVelocityY(this.jumpSpeed),this.lastJumpTime=this.scene.time.now)}}else this.resetPatrol&&(s.Math.Within(this.initialX,this.sprite.x,1)||s.Math.Within(this.initialY,this.sprite.y,1))&&(this.resetPatrol=!1,this.initialX=this.sprite.x,this.initialY=this.sprite.y),this.sprite.x>=this.initialX+this.patrolDistance/2?this.direction=-1:this.sprite.x<=this.initialX-this.patrolDistance/2&&(this.direction=1),this.sprite.body.blocked.left?this.direction=1:this.sprite.body.blocked.right&&(this.direction=-1),this.sprite.body.setVelocityX(this.direction*this.speed)}hitPlayer(t,e){this.player.takeDamage(e,t,this.damage)}}class y{constructor(t,e,s){this.scene=t,this.player=s,this.type=e.type,this.x=e.x,this.y=e.y,"h"===this.type?(this.healthAmount=1,this.color=65280,this.size=16):"H"===this.type&&(this.healthAmount=2,this.color=32768,this.size=24),this.createSprite(),t.physics.add.overlap(this.sprite,s.sprite,this.collectItem,null,this),this.sprite.setData("instance",this)}createSprite(){this.sprite=this.scene.add.circle(this.x,this.y,this.size/2,this.color)}collectItem(t,e){this.player.addHealth(this.healthAmount),t.destroy()}}class u{constructor(t,e,s={}){if(this.scene=t,this.kinematics=e,this.levelOptions=s,this.walls=t.physics.add.staticGroup(),this.platforms=t.physics.add.staticGroup(),this.spikes=t.physics.add.staticGroup(),this.stars=t.physics.add.group(),this.enemies=t.physics.add.group(),this.items=t.physics.add.staticGroup(),this.inventory=new c,s.asciiMap){const t=new d(s.asciiMap,{spikeTines:this.levelOptions.spikeTines||1}),{wallData:e,platformData:i,spikeData:h,enemyData:a,itemData:r}=t.parse();
this.wallData=e,this.platformData=i,this.spikeData=h,this.enemyData=a,this.itemData=r}else this.wallData=[{x:400,y:568,width:800,height:64,color:2263842,name:"ground"},{x:600,y:400,width:150,height:32,color:9127187},{x:50,y:250,width:150,height:32,color:9127187},{x:750,y:220,width:150,height:32,color:9127187}],this.platformData=[{x:400,y:350,width:200,height:16,color:8388736}],this.spikeData=[{x:775,y:522,width:60,height:28,tines:15,color:8421504},{x:25,y:522,width:50,height:28,tines:15,color:8421504}],this.itemData=[],this.enemyData=[];
this.createEnemies(),this.createItems(),this.createWalls(),this.createPlatforms(),this.createSpikes()}createEnemies(){this.enemyData.forEach((t=>{const e=new p(this.scene,t,this.scene.player,this);
    this.enemies.add(e.sprite)}))}createItems(){this.itemData.forEach((t=>{const e=new y(this.scene,t,this.scene.player);
    this.items.add(e.sprite)}))}createWalls(){this.wallData.forEach((t=>{let e=this.scene.add.rectangle(t.x,t.y,t.width,t.height,t.color);
    e.name=t.name||"",this.scene.physics.add.existing(e,!0),this.walls.add(e)}))}createPlatforms(){this.platformData.forEach((t=>{let e=this.scene.add.graphics();
    e.fillStyle(t.color,1),e.fillRoundedRect(0,0,t.width,t.height,10);
    let s="platform_"+t.x+"_"+t.y;
    e.generateTexture(s,t.width,t.height),e.destroy();
    let i=this.scene.add.image(t.x,t.y,s).setOrigin(.5,.5);
    this.scene.physics.add.existing(i,!0),this.platforms.add(i),i.body.setSize(t.width,t.height)}))}createSpikes(){this.spikeData.forEach((t=>{const e=t.width,s=e/t.tines,i=s/2;
    for(let h=0;
    h<t.tines;
    h++){let a=t.x-e/2+h*s+s/2+i,r=t.y+t.height/2,o=this.scene.add.triangle(a,r,-s/2,t.height/2,0,-t.height/2,s/2,t.height/2,t.color);
    this.scene.physics.add.existing(o,!0),this.spikes.add(o),o.body.setOffset(-i,0)}}))}update(t,e){this.enemies.children.iterate((s=>{const i=s.getData("instance");
    i&&i.update(t,e)}))}destroy(){this.walls.clear(!0,!0),this.platforms.clear(!0,!0),this.spikes.clear(!0,!0),this.stars.clear(!0,!0)}}const m="\nw - wall or floor\nP - platform (can jump up through)\ns - spikes (facing up)\nE - flying enemy\ne - walking enemy\nh - health pickup\nH - bigger health pickup\n. - empty space\n---\n........................................\n........................................\n..........E..........e..................\n........................................\n.........ppp.........E..................\n......................h.................\n..H..................wwww...............\nwwww....................................\n..................e.....................\n...........h.H..........................\n.........ppppppp........................\n.......................wwwwww...........\n........................................\n........................................\n......................w.w...............\nss....................sss...............\nwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\nwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n".trim().split("\n");
class w extends u{static defaultStarFactor=1;
    constructor(t,e,s,i,h=1,a){super(t,e,{asciiMap:localStorage.level1 ? JSON.parse(localStorage.level1).trim().split('\n') : m,spikeTines:3}),this.difficultySettings=s,this.levelNumber=i,this.levelIndexInType=h;
const r=this.difficultySettings.getStarLevelOptions(h);
this.starIncreasePerLevel=r.starIncreasePerLevel,this.starFactor=w.defaultStarFactor+(this.levelIndexInType-1)*this.starIncreasePerLevel,this.createStars(),t.physics.add.collider(this.stars,this.walls,this.starWallCollision,null,this),t.physics.add.collider(this.stars,this.platforms),t.physics.add.collider(this.stars,this.spikes),t.physics.add.collider(this.stars,this.stars),this.scene.physics.add.overlap(this.stars,a.sprite,this.collectStar,null,this),this.player=a}createStars(){let t=this.starFactor;
    for(let e=0;
    e<t;
    e++){let t=s.Math.Between(50,750),e=s.Math.Between(50,300),i=this.scene.add.circle(t,e,7,16776960);
    this.scene.physics.add.existing(i),this.stars.add(i),i.body.setBounce(this.kinematics.defaultItemBounce.x,this.kinematics.defaultItemBounce.y),i.body.setCollideWorldBounds(!0),i.body.setVelocity(s.Math.Between(-100,100),s.Math.Between(-100,100))}this.totalStars=t}starWallCollision(t,e){t.body.velocity.x*=.9,t.body.velocity.y*=.9,"ground"==e.name&&(t.body.velocity.x*=.5,t.body.velocity.y*=.5)}collectStar(t,e){e.destroy(),this.player.score+=10,0===this.stars.countActive(!0)&&this.scene.levelComplete()}}class g extends u{constructor(t,e,s,i,h=1,a){super(t,e),this.difficultySettings=s,this.levelNumber=i,this.levelIndexInType=h,this.difficultySettings.getFloatingStarLevelOptions(h),this.numberOfStars=this.levelIndexInType,this.createStars(),this.scene.physics.add.overlap(this.stars,a.sprite,this.collectStar,null,this),this.player=a}createStars(){for(let t=0;
    t<this.numberOfStars;
    t++){let t=s.Math.Between(50,750),e=s.Math.Between(50,300),i=this.scene.add.circle(t,e,7,16776960);
    this.scene.physics.add.existing(i),this.stars.add(i),i.body.setAllowGravity(!1),i.body.setImmovable(!0),Math.random()>.5?this.addHoverAnimation(i):this.addRotateAnimation(i)}this.totalStars=this.numberOfStars}addHoverAnimation(t){let e=s.Math.Between(20,50),i=s.Math.Between(2e3,4e3);
    this.scene.tweens.add({targets:t,y:t.y+e,yoyo:!0,repeat:-1,ease:"Sine.easeInOut",duration:i})}addRotateAnimation(t){let e=t.x,i=t.y,h=s.Math.Between(20,50),a=0,r=s.Math.FloatBetween(.01,.03);
    this.scene.events.on("update",(()=>{a+=r,t.x=e+h*Math.cos(a),t.y=i+h*Math.sin(a)}))}collectStar(t,e){e.destroy(),this.player.score+=10,0===this.stars.countActive(!0)&&this.scene.levelComplete()}}class f extends u{constructor(t,e,s,i,h=1,a){super(t,e),this.player=a,this.difficultySettings=s,this.levelNumber=i,this.levelIndexInType=h;
    const r=this.difficultySettings.getBallLevelOptions(h);
    this.numberOfBalls=r.numberOfBalls,this.elasticity=r.elasticity,this.createBalls(),this.createWinCondition(),t.physics.add.collider(this.stars,this.walls),t.physics.add.collider(this.stars,this.platforms),t.physics.add.collider(this.stars,this.spikes),t.physics.add.collider(this.stars,this.stars),t.physics.add.collider(this.stars,a.sprite)}createBalls(){for(let t=0;
    t<this.numberOfBalls;
    t++){let t=s.Math.Between(50,750),e=s.Math.Between(50,300),i=this.scene.add.circle(t,e,10,255);
    this.scene.physics.add.existing(i),this.stars.add(i),i.body.setBounce(this.elasticity),i.body.setCollideWorldBounds(!0),i.body.setVelocity(s.Math.Between(-200,200),s.Math.Between(-200,200))}}createWinCondition(){this.winObject=this.scene.add.triangle(400,50,0,60,60,60,30,0,16776960),this.scene.physics.add.existing(this.winObject),this.winObject.body.allowGravity=!1,this.winObject.body.setCollideWorldBounds(!0),this.winObject.body.setImmovable(!0),this.winObject.body.setVelocityX(100),this.winObject.body.setBounce(1,0),this.scene.physics.add.overlap(this.winObject,this.player.sprite,(()=>{this.scene.levelComplete()}))}update(){}}class x{constructor(t,e){this.player=t,this.kinematics=e,this._totalWeight=this.player.inventory.totalWeight,this.baseSpeed=160,this.baseJumpSpeed=this.kinematics.jumpSpeed,this.updateMovementFactors()}get totalWeight(){return this._totalWeight}set totalWeight(t){this._totalWeight!==t&&(this._totalWeight=t,this.updateMovementFactors())}updateMovementFactors(){let t=1-this.totalWeight*this.kinematics.weightSlowFactor;
    t=s.Math.Clamp(t,this.kinematics.minPlayerSpeed,this.kinematics.maxPlayerSpeed),this._currentSpeed=this.baseSpeed*t;
    let e=1-this.totalWeight*this.kinematics.weightJumpFactor;
    e=s.Math.Clamp(e,this.kinematics.minPlayerJumpSpeed,this.kinematics.maxPlayerJumpSpeed),this._currentJumpSpeed=this.baseJumpSpeed*e}get currentSpeed(){return this._currentSpeed}get currentJumpSpeed(){return this._currentJumpSpeed}updateTotalWeight(){let t=this.player.inventory.totalWeight;
    this.totalWeight=t}}class S{constructor(t,e,s,i,h){this.scene=t,this.x=e,this.y=s,this.direction=i,this.type=h,this.sprite=t.physics.add.image(this.x,this.y,this.type.textureKey),this.sprite.setScale(1),this.sprite.body.allowGravity=!1,this.sprite.body.setCollideWorldBounds(!1)}init(){let t=this.type.speed;
    "left"===this.direction?this.sprite.setVelocityX(-t):this.sprite.setVelocityX(t),this.scene.time.delayedCall(1e3,(()=>{this.sprite.destroy()}))}}class v{static defaultMaxHearts=4;
    constructor(t,e=100,s=450,i={},h,a,r){this.scene=t,this.x=e,this.y=s,this.kinematics=h,this.projectileType=a,this.difficultySettings=r,this.color=void 0===i.playerColor?16711680:i.playerColor,this.maxHearts=i.maxHearts||v.defaultMaxHearts,this.hearts=this.maxHearts,this.recoilTimer=400,this.invulnerable=!1,this.inventory=new c,this.score=0,this.sprite=t.add.rectangle(this.x,this.y,32,48,this.color),t.physics.add.existing(this.sprite),this.sprite.body.setCollideWorldBounds(!0),this.sprite.body.setGravityY(this.kinematics.gravityY),this.facing="right",this.lastFired=0,this.isJumping=!1,this.jumpTime=0,this.movementFactors=new x(this,this.kinematics),this.projectiles=t.physics.add.group(),this.heartsGroup=t.add.group(),this.createHeartsDisplay(),this.scoreText=t.add.text(20,50,"Score: 0",{fontSize:"16px",fill:"#000"}),this.scoreText.setScrollFactor(0)}createHeartsDisplay(){this.heartsGroup.clear(!0,!0);
    for(let t=0;
    t<this.maxHearts;
    t++){const e=20,s=16;
    let i=16711680,h=e+t*e,a=20;
    if(t<Math.floor(this.hearts)){let t=this.scene.add.rectangle(h,a,s,s,i);
    this.heartsGroup.add(t)}else{let e=8421504,r=this.scene.add.rectangle(h,a,s,s,e);
    if(this.heartsGroup.add(r),t<this.hearts){let t=this.scene.add.rectangle(h-s/4,a,s/2,s,i);
    this.heartsGroup.add(t)}}}this.heartsGroup.children.each((t=>{t.setScrollFactor(0)}))}platformCollisionCallback(t,e){return t.body.velocity.y>0&&!this.scene.inputManager.isDownPressed()}addHealth(t){this.hearts+=t,this.hearts>this.maxHearts&&(this.hearts=this.maxHearts),this.createHeartsDisplay()}update(t,e,s){this.movementFactors.updateTotalWeight();
    let i=this.movementFactors.currentSpeed,h=this.movementFactors.currentJumpSpeed;
    this.sprite.body.setVelocityX(0),t.isLeftPressed()?(this.sprite.body.setVelocityX(-i),this.facing="left"):t.isRightPressed()&&(this.sprite.body.setVelocityX(i),this.facing="right");
    const a=this.sprite.body.blocked.down||this.sprite.body.touching.down;
    t.isUpPressed()||t.isSpacePressed()?a?(this.isJumping=!0,this.jumpTime=0,this.sprite.body.setVelocityY(h)):this.isJumping&&this.jumpTime<this.kinematics.maxJumpTime?(this.sprite.body.setVelocityY(h),this.jumpTime+=this.scene.game.loop.delta):this.isJumping=!1:this.isJumping=!1,t.isDownPressed()&&!a?this.sprite.body.setGravityY(4*this.kinematics.gravityY):this.sprite.body.setGravityY(this.kinematics.gravityY),t.isShiftPressed()&&s-this.lastFired>this.projectileType.cooldown&&(this.fireProjectile(),this.lastFired=s),this.scoreText.setText("Score: "+this.score)}fireProjectile(){let t=this.sprite.x,e=this.sprite.y,s=new S(this.scene,t,e,this.facing,this.projectileType);
    this.projectiles.add(s.sprite),s.init();
    let i=s.type.recoilForce;
    i-=this.inventory.totalWeight,i=Math.max(i,0),"left"===this.facing?this.sprite.body.velocity.x+=i:this.sprite.body.velocity.x-=i}takeDamage(t,e,s=this.difficultySettings.spikeDamage){if(!this.invulnerable){if(this.invulnerable=!0,this.hearts-=s,this.hearts<0&&(this.hearts=0),this.createHeartsDisplay(),this._damageRecoil(t,e,s),this.scene.time.delayedCall(this.recoilTimer,(()=>{this.invulnerable=!1})),!this.flashTween){const e=4;
    this.flashTween=this.scene.tweens.add({targets:t,duration:this.recoilTimer/e/2-10,alpha:.25,ease:"Linear",yoyo:!0,repeat:e-1,onComplete:()=>{t.alpha=1,this.flashTween=null}})}this.hearts<=0&&this.scene.scene.start("GameOverScene")}}_damageRecoil(t,e,i){const h=new s.Math.Vector2(t.x-e.x,-Math.abs(t.y-e.y)).normalize(),a=i/this.maxHearts*v.defaultMaxHearts*200,r=i/this.maxHearts*v.defaultMaxHearts*100;
    t.useVelocity?(t.body.touching.left?t.body.velocity.x=a:t.body.touching.right&&(t.body.velocity.x=-a),t.body.velocity.y=-r):(t.body.velocity.x=h.x*a,t.body.velocity.y=h.y*r)}destroy(){this.sprite.destroy(),this.projectiles.clear(!0,!0),this.heartsGroup.clear(!0,!0),this.scoreText.destroy()}}class b extends s.Scene{constructor(){super({key:"MainScene"})}init(t){this.currentLevel=t.level||1,this.gameMode=t.gameMode||"easy",this.game.registry.set("gameMode",this.gameMode)}preload(){}create(){this.cameras.main.setBackgroundColor("#87CEEB"),this.difficultySettings=new o,this.kinematics=new l(this.currentLevel),this.projectileType=new n(this,{size:{width:10,height:10},shape:"triangle",speed:500,color:16776960,cooldown:200,recoilForce:100});
let t=this.game.registry.get("playerColor");
if(t=void 0===t?16711680:t,this.player=new v(this,100,450,{maxHearts:4,playerColor:t},this.kinematics,this.projectileType,this.difficultySettings),this.inputManager=new r(this),this.levelProgression=this.difficultySettings.game.getProgression(this.gameMode),this.currentLevel<=this.levelProgression.length){{const t=this.levelProgression[this.currentLevel-1];
    let e;
    switch(t.levelType){case"StarLevel":default:e=w;
    break;
    case"FloatingStarLevel":e=g;
    break;
    case"BallLevel":e=f}const s=t.levelIndexInType;
this.level=new e(this,this.kinematics,this.difficultySettings,this.currentLevel,s,this.player)}this.levelText=this.add.text(this.cameras.main.width/2,this.cameras.main.height/2,"Level "+this.currentLevel,{fontSize:"64px",fill:"#fff"}).setOrigin(.5),this.time.delayedCall(1500,(()=>{this.levelText.destroy()}),[],this),this.physics.add.collider(this.level.stars,this.player.projectiles),this.physics.add.collider(this.player.sprite,this.level.walls),this.physics.add.collider(this.player.sprite,this.level.platforms,null,this.player.platformCollisionCallback,this.player),this.physics.add.overlap(this.player.sprite,this.level.spikes,this.player.takeDamage,null,this.player)}else this.scene.start("CongratulationsScene",{totalScore:this.player?this.player.score:0})}update(t,e){this.player.update(this.inputManager,null,t),this.level.update&&this.level.update(t,e)}levelComplete(){this.currentLevel+=1,this.game.registry.set("lastLevel",this.currentLevel),this.scene.restart({level:this.currentLevel,gameMode:this.gameMode})}}class I extends s.Scene{constructor(){super({key:"GameOverScene"})}create(){this.selectedOptionIndex=0,this.options=["Title Screen","Retry","Restart"],this.optionButtons=[],this.defaultTextStyle={fontSize:"32px",fill:"#888"},this.highlightedTextStyle={fontSize:"32px",fill:"#fff"},this.cameras.main.setBackgroundColor("#000000"),this.add.text(400,150,"Game Over",{fontSize:"64px",fill:"#a0f"}).setOrigin(.5);
this.options.forEach(((t,e)=>{let s=this.add.text(400,300+50*e,t,this.defaultTextStyle).setOrigin(.5).setInteractive();
    s.on("pointerdown",(()=>{this.selectedOptionIndex=e,this.startSelectedOption()})),s.on("pointerover",(()=>{this.selectedOptionIndex=e,this.updateOptionStyles()})),this.optionButtons.push(s)})),this.cursors=this.input.keyboard.createCursorKeys(),this.enterKey=this.input.keyboard.addKey(s.Input.Keyboard.KeyCodes.ENTER),this.updateOptionStyles(),this.events.on("shutdown",this.shutdown,this)}update(){s.Input.Keyboard.JustDown(this.cursors.up)?(this.selectedOptionIndex=(this.selectedOptionIndex+this.options.length-1)%this.options.length,this.updateOptionStyles()):s.Input.Keyboard.JustDown(this.cursors.down)?(this.selectedOptionIndex=(this.selectedOptionIndex+1)%this.options.length,this.updateOptionStyles()):s.Input.Keyboard.JustDown(this.enterKey)&&this.startSelectedOption()}updateOptionStyles(){this.optionButtons.forEach(((t,e)=>{e===this.selectedOptionIndex?t.setStyle(this.highlightedTextStyle):t.setStyle(this.defaultTextStyle)}))}startSelectedOption(){switch(this.selectedOptionIndex){case 0:this.scene.start("TitleScene");
    break;
    case 1:this.scene.start("MainScene",{level:this.game.registry.get("lastLevel")||1,gameMode:this.game.registry.get("gameMode")});
break;
case 2:this.scene.start("MainScene",{level:1,gameMode:this.game.registry.get("gameMode")})}}shutdown(){this.input.keyboard.shutdown(),this.events.off("shutdown",this.shutdown,this)}}class T extends s.Scene{constructor(){super({key:"CongratulationsScene"})}init(t){this.totalScore=t.totalScore||0}create(){this.cameras.main.setBackgroundColor("#000000"),this.add.text(400,200,"Congratulations!",{fontSize:"64px",fill:"#fff"}).setOrigin(.5),this.add.text(400,300,"Total Score: "+this.totalScore,{fontSize:"32px",fill:"#fff"}).setOrigin(.5),this.add.text(400,400,"Play Again",{fontSize:"32px",fill:"#fff",backgroundColor:"#00ff00"}).setOrigin(.5).setInteractive().on("pointerdown",(()=>{this.scene.start("MainScene",{level:1,gameMode:"easy"})}))}}const k={type:s.AUTO,scale:{mode:s.Scale.FIT},width:800,height:600,physics:{default:"arcade",arcade:{gravity:{y:300},debug:!1}},scene:[i,h,b,I,T]},C=new s.Game(k),O=()=>{setTimeout((()=>{C.scale.setParentSize(window.innerWidth,window.innerHeight)}),100)};
return O(),window.addEventListener("orientationchange",(()=>{O()})),C.scene.start("TitleScene"),C}(Phaser);

//# sourceMappingURL=boxy.min.js.map
